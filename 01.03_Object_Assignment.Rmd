
## Object Assignment {#Object-Assignment}

```{r, echo=FALSE}
rm(list=ls())
```

```{r, include=FALSE}
knitr::opts_chunk$set(
  comment = "#>", echo = TRUE, eval = TRUE, results = FALSE, error = TRUE, fig.width = 6, warning = FALSE, collapse = TRUE)
```


In the last section, you have seen the power of R as a fancy calculator. However, in order to do more complicated and interesting tasks, it is super helpful to store intermediate results for future use.  

Let's take a look at a concrete example. Say if you want to do the following three calculations, all involving `exp(3) / log(20,3) * 7`.  

```{r}
(exp(3) / log(20,3) * 7) + 3 #addition
(exp(3) / log(20,3) * 7) - 3 #subtraction
(exp(3) / log(20,3) * 7) / 3 #division
```

Using R as a fancy calculator (Section \@ref(Calculator)), you need to type the expression `exp(3) / log(20,3) * 7` three times, which is a bit cumbersome. In this section, you will learn how to do **object assignment**, which can avoid the need for typing the expression more than once. 

### What is an R Object?

Before we get into the details, let's first introduce **object**, which is perhaps the most fundamental thing in R. In principle, **everything that exists in R is an object**. For example, the number `5` is an object, the expression `1 + 2` is an object, and the expression `exp(3) / log(20,3) * 7` is also an object. 

If you run `5`, you will get one element of value 5 from the output. Similarly, if you run `1 + 2`, you will get one element of value 3 from the output. You can try to run `exp(3) / log(20,3) * 7` by yourself.  In these three examples, you can see that there is only one **element** in each object.

However, an object can contain more than one elements, and each element has its own **value**, which are possibly different. And naturally, different objects can contain different values.

### Assignment Operation with `<-` {#assignment}

With the importance of objects in mind, let's learn how to do **object assignments** in R. To do object assignments, you need to assign **value(s)** to a **name** via the **assignment operator**, which will create a new object with the name you specified. Once the object assignment operation is done, you can simply use the name in subsequent calculations without redundancy. Let's start with a simple example,

```{r results = TRUE}
x_numeric <- 5
```

The assignment operation has three components. From left to right，

- the first component `x_numeric` is the **object name** of a new object, which has certain naming rules that will be discussed shortly in Section \@ref(Naming). 
- The second component is the **assignment operator** `<-`, which is a combination of the less than sign `<` immediately followed by the minus sign `-`, with **no space** in between. 
- The final component is the **value(s)** to be assigned to the name, which is 5 here. 

::: {.infobox .caution data-latex="{caution}"}
There is no space between `<` and `-` in the assignment operator `<-`. Note that although `=` may also appear to be working as the assignment operator, it is not recommended as `=` is usually reserved for specifying the value(s) of arguments in a function call, which will be introduced in Section \@ref(vector-patterns).
:::

After running the code above, you will see no output in the console, unlike the situation when we ran `1 + 2` which gives us the answer `3` (as shown in the Figure \@ref(fig:noa)). You may be wondering, did we successfully make our first assignment operation? 

```{r noa, results=TRUE, echo=FALSE, fig.align = 'center', fig.cap="No output", out.width = '70%'}
knitr::include_graphics("pics/2noa.PNG")
```

To verify it, you can run the code with just the object name to check its value. (For all named objects, you can get their value(s) by running codes with just their names.)

```{r results = TRUE}
x_numeric
```

Great! The output is 5, indicating that you have successfully assigned the value 5 to the name x_numeric, and you have created a new object `x_numeric`. You can use `x_numeric` instead of `5` to do the subsequent calculations because `x_numeric` and `5` have the same value. 

In addition, you can assign **value(s)** of an expression to a name. Let's try to simplify the three expressions we did at the beginning of this section. It is easy to observe that the three lines of codes share a common term `exp(3) / log(20,3) * 7`. Let's assign the value of the common term to a name. 

```{r results = TRUE}
y_numeric <- exp(3) / log(20,3) * 7
y_numeric
```

Now you have successfully created an object `y_numeric` with value `r y_numeric`. Using the named object `y_numeric`, you can simplify the three calculations as follows. 

```{r, eval=FALSE}
y_numeric + 3
y_numeric - 3
y_numeric / 3
```

::: {.infobox .caution data-latex="{caution}"}
Note that in the object assignment process, it is not the expression itself but rather the value(s) of the expression, that is assigned to a name. So you will not get the expression `exp(3) / log(20,3) * 7` from `y_numeric`. 
:::



You can also try the following examples by yourself.

```{r, eval=FALSE}
a <- floor(7 / 3) 
a
b <- 7%/%3
b
```

Clearly, using the object assignment, you can greatly simplify the code and avoid redundancy. 

Note that R object names are **case-sensitive**. For example, you have defined `x_numeric`, but if you type `X_numeric`, you will get an error message as follow. 

```{r, error = TRUE}
X_numeric
```



### Review objects in environment

After creating new objects `x_numeric` and `y_numeric`, they will appear in the **Environment**, located in the top right panel (**panel3 in Figure \@ref(fig:four)**). You can check all the **named objects** and their values in this area. It is helpful to monitor the environment from time to time to make sure everything looks fine. Notice that objects without names will *not* be shown in the environment.

You can also see the list of all the named objects using function `ls()`.

```{r, results = TRUE}
ls()
```

All the objects shown in the environment or on the list are stored in the memory, so they are available for us in the subsequent codes. It is a good habit to do object assignments if you want to retrieve their values at a later time.

### Object naming rule {#Naming}

In general, R is very flexible in the name you can give to an object，however, there are three important rules you need to follow.

***a. Must start with a letter or . (period)***     
In addition, if starting with period, the second character can't be a number.   

***b. Can only contain letters, numbers, `_` (underscore), and `.` (period)***
One recommended naming style is to use lowercase letters and numbers, and use underscore to separate words within a name. So you can use relatively longer names that is more readable.

***c. Can not use special keywords as names.***
For example, **TRUE <- 12** is not permitted as `TRUE` is a special keyword in R. You can see from the following that this assignment operation leads to an error message. 

```{r error=TRUE}
TRUE <- 12
```

Some commonly used reserved keywords that cannot be used as names are listed as below.


```{r results = TRUE, echo=FALSE, warning=FALSE}
Keys  <- c("break", "else", "FALSE", "for", "function", "if", "Inf", "NA", "NaN", "next", "repeat", "return", "TRUE", "while")
key_mat <- matrix(Keys, 7, 2)
knitr::kable(key_mat)
```

To get a complete list of reserved words, you can run the following code.
```{r, eval = FALSE}
?Reserved
```


### Object types

So far in this section, you have learned how to do object assignments. The values you assigned are all numbers, i.e. of numeric type. Actually, an object may contain more than one values. Also, the values it contains can be of other types than numeric, including character and logical. Depending on the **composition of values**, the object belongs to one particular type. 



```{r echo = FALSE, results = TRUE}
Type  <- c("Atomic Vector","Matrix","Array","Data Frame", "List")
Section <- c("\\@ref(vector)","\\@ref(matrix)","\\@ref(array)","\\@ref(dataframe)","\\@ref(list)")
d <- data.frame(Type, Section)
knitr::kable(d)
```

We will focus on atomic vectors in Chapter \@ref(r-objects) and discuss other object types in Chapter \@ref(r-objects-other-types).

While some of the object types look more intuitive than others, you have nothing to worry about since we have the next two chapters devoted to the details of R objects. Objects are the building blocks of R programming and it will be time well spent mastering every object type. 


### Exercises

1. Write R code to assign the value 20 to the name `num_1`.

2. Which of the following is a valid object name in R?

- `2.True`
- `else`
- `I_am_not_a_valid_name`
- `I_am_a_Pretty#_name`

3. Write R code to get the list of all objects in the environment.

<<<<<<< HEAD
=======

>>>>>>> e5b4e15619ce4762dabe335c7edeccecb8a5b818
