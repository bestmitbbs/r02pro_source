
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### General Vector Application and the Coercion Rule

At this point, we have introduced three types of atomic vectors: numeric, character, and logical vectors. You may wonder what if we have a vector with a mix of different types of values, and that is the question we are going to answer in this section. Before that, there are a couple useful functions that we would like to introduce first. 

### Vector creation with c() and vector()

Let's first review some basic properties of a vector, with the `c()` function. 

```{r}
some_double <- c(2, 4, 6)
class(some_double)  # class
is.numeric(some_double) 
typeof(some_double) # storage type

some_char <- c("NYU", "GPH", "Biostats")
class(some_char)
is.character(some_char)
typeof(some_char)
```

Note that function `vector()` can be used to create empty vector with specified storage type. This will come in handy later in this book. 

```{r}
some_x <- vector("numeric", 10)
some_x

some_y <- vector("character", 10)
some_y 
```

Now let's talk about the coercion rule. R will unify all values into the most complex one from the given vector, and this converting process is usually called the coercion rule. Specifically, R uses the following order of complexity: logical < numeric < char

### Inmplicit Coercion

The first example demonstrates the coercion rule between logical and numeric values. 

```{r}
mix_1 <- c(TRUE, 3, 4, FALSE)
mix_1
# [1] 1 3 4 0
typeof(mix_1)
# [1] "double"
class(mix_1)
# [1] "numeric"
```

You can see that when logical values are combined with numbers in the same vector, in particular, TRUE will be converted to 1 and FALSE will be converted to 0, because numbers are more complex than logical values, and R will unify all values into the most complex one. The result of coercion can be confirmed with the `typeof()` and the `class()` function. This is one of the most commonly used coercion rule in R.

Another example of implicit coercion is between characters and numbers, as shown in the example: 

```{r}
mix_2 <- c(8, "happy", 26, "string")
mix_2 
#> [1] "8"      "happy"  "26"     "string"
typeof(mix_2)
#> [1] "character"
class(mix_2)
#> [1] "character"
```

You can see that both 8 and 26 are converted into strings since strings are more complex than numbers. Then mix_2 will be a character vector. 

Next, we will introduce coercion rule in functions. You may noticed that when creating a vector with `c()`, we already used this function to achieve coercion. Other function like `paste()` would do the same when you bring numbers, characters, and logical values together. 

```{r}
mix_3 <- c(16, TRUE, "truth")
mix_3
#> [1] "16"   "TRUE" "truth"
class(mix_3)
#> [1] "character"
mix_4 <- paste(16, TRUE, "truth")
mix_4
#> [1] "16 TRUE truth"
class(mix_4)
#> [1] "character"
```

What if you put multiple `c()` together to create a single vector? Nested c() will collapse into a single vector recursively. However, if you create another vector mix_4, you first have c(16, TRUE) which will be converted to c(16, 1) since numbers are more complex than logical values. Then, c(16, 1) will be converted to c("16", "1") when you combine it with "truth", leading to the results of mix_4.

```{r}
mix_5 <- c(c(1, TRUE), 3, "truth")
mix_5
```

### Explicit Coercion

Explicit coercion occurs when you manually invoke functions like `as.numeric()`, `as.logical()`, and `as.character()`, which will covert the vector into the specified type. Be sure to check the original type of the vector before you apply any of these conversion, as some of them may not be reversable. 

```{r}
as.numeric(c(TRUE, FALSE))
#> [1] 1 0
as.logical(c(1, 0))
#> [1]  TRUE FALSE
as.logical(c("TRUE", "FALSE"))
#> [1]  TRUE FALSE
```

### Comparision between differnt types

When comparing vectors of different types, the coercion rule will apply. Take the following vectors as example:

```{r}
a <- c(-1, 0, 1)
b <- c(TRUE, FALSE, TRUE)
a == b
#> [1] FALSE  TRUE  TRUE
```

When we are trying to figure out if a is equal to b, we get a length-3 logical vector. Elements in b is first converted into 1 and 0 based on the coercion rule we previously introduced, which is TRUE = 1 and FALSE = 0, and the result will be c(1, 0, 1). Thus, a comparison between a logical and a numeric vector is changed into comparing two numeric vectors. 

You can make comparisons between vectors of other types, the following example shows that the classic transitive property in math (a = b and b = c imply a = c) doesn't hold in R. 

```{r}
1 == TRUE
#> [1] TRUE
TRUE == "TRUE"   
#> [1] TRUE
1 == "TRUE"
#> [1] FALSE
```
