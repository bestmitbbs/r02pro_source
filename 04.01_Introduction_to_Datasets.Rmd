## Introduction to the Ames Housing Price Data Set {#intro-dataset}

Before generating any beautiful plots, let's first introduce the data set that will be used throughout this chapter. The data set is a part of the Ames Housing Price data, containing 165 observations and 12 features including the sale date and price. 

The data set `sahp` is located in the R package **r02pro**, the companion package of this book.
Besides the **r02pro** package, we will also extensively use the **ggplot2** package for visualization in this chapter. Like the **tibble** package, **ggplot2** is another member of the **tidyverse** package. You can install the **ggplot2** package if you haven't done so. 
```{r, eval=FALSE}
install.packages("ggplot2")
```

First, let's load the **r02pro**, **ggplot2**, and **tibble** packages.
```{r}
library(r02pro)
library(ggplot2)
library(tibble)
```

After loading the three packages, you can type `sahp` to have a quick look of the dataset.
```{r, results = TRUE}
sahp
```

You can see that `sahp` is a *tibble* with 165 observations and 12 variables. By default, the output only shows the first 10 observations in the tibble along with the first few variables that can fit the window. To view the full dataset, you can use the `view()` function, which will open the dataset in a new window. 
```{r, eval=FALSE}
view(sahp)
```

To view the top rows of the dataset, you can 
use the `head()` function, which produces the first 6 observations by default. You can also set an optional second argument to pick any given number of observations. 
```{r}
head(sahp)
head(sahp, 15)
```

To get a first impression on the dataset, you can use the `summary()` function introduced in Section \@ref(vector-functions). 
```{r}
summary(sahp)
```
In the output, we get the summary statistics for each variable. For numeric variables, we get the minimum, 1st quartile, median, mean, 3rd quartile, and the maximum. It also shows the number of `NA`s for a particular variable. For character variables, we only get the length of the vector, the class, and the mode. 

Although the types of each variable are shown in the result when typing `sahp`, a more detailed list can be found with the function `str()`. 

```{r, results=TRUE}
str(sahp)
```

The `str()` function gives a list of each component, the corresponding type, the length, and the first several values. 

### Are two-story houses more expensive than one-story ones? 

Let's try to answer this question by doing some analysis. First, let's create the logical vectors corresponding to two-story and one-story houses. 

```{r}
story_2 <- sahp$house_style == "2Story"
story_1 <- sahp$house_style == "1Story"
```

Then, we create two vectors containing the prices of the two groups, respectively. 

```{r}
sale_price_2 <- sahp$sale_price[story_2]
sale_price_1 <- sahp$sale_price[story_1]
```

Finally, we can run the `summary()` function on both vectors.
```{r, results=TRUE}
summary(sale_price_2)
summary(sale_price_1)
```
From these summaries, it is clear that the corresponding statistic is larger for two-story houses compared with one-story ones, for all 6 measures. As a result, we can draw the conclusion that the two-story houses indeed have a higher sale price than the one-story ones.

### Converting Data Types

When you import a data set into R, some variables may not have the desired types.  In this case, it would be useful to convert them into the types you want before conducting further data analysis. 


***a. Convert a character vector to an unordered factor***

Let's look at the variable `house_style` in `sahp`. We can see from the output of `str(sahp)` that it is of `chr` type. Let's confirm this and get it summary.

```{r, results=TRUE}
is.character(sahp$house_style)
summary(sahp$house_style)
```

As briefly mentioned before, using the `summary()` function on a character vector doesn't provide us much useful information. Let's find the unique values of this vector and get the frequency table.
```{r, results=TRUE}
unique(sahp$house_style)
table(sahp$house_style)
```
We can see that there are five house styles along with their frequencies. It turns out to be particularly useful to convert this type of variable into a *factor* type. Let's use the function `as.factor()` and run the summary function again. 
```{r, results=TRUE}
house_style_factor <- factor(sahp$house_style)
summary(house_style_factor)
```

***b. Convert a character vector to an ordered factor***

Now, let's take a look at another variable called `kit_qual`, measuring the kitchen quality. Again, let's check the unique values.

```{r, results=TRUE}
unique(sahp$kit_qual)
```

In addition to having four different quality values, they have an internal ordering among them. In particular, we know Fair < Average < Good < Excellent. To reflect this, you can convert this variable in to an *ordered factor* using the `factor()` function. In particular, the `ordered = TRUE` argument reflects that we want to create an ordered factor. 
```{r, results=TRUE}
kit_qual_ordered_factor <- factor(sahp$kit_qual, ordered = TRUE, levels = c("Fair", "Average", "Good", "Excellent"))#covert to ordered factor
summary(kit_qual_ordered_factor)
str(kit_qual_ordered_factor)
```

***c. Convert a character vector to a logical vector***

Lastly, let's look at the variable `central_air`, representing whether the house has central AC or not. As before, let's get the unique elements. 
```{r, results=TRUE}
unique(sahp$central_air)
```

Intuitively, you can create a logical vector representing whether the house has central AC. 

```{r}
central_air_logi <- sahp$central_air == "Y"
summary(central_air_logi)
str(central_air_logi)
```

Sometimes, you may also want to create additional variables from the existing ones. For example, we know the  overall quality of the house ranges from 2 to 10. 
```{r}
table(sahp$oa_qual)
```
Maybe we want to call a house of good quality if `oa_qual` is larger than 5.  We can then create a new logical variable as follows.
```{r}
good_qual <- sahp$oa_qual > 5
```


### Recover Modified Values

When you are working with a data set inside a package, you may accidentally modified some values in place by mistake. In this situation, you don't need to panic as you can easily recover the data set into a faculty setting (i.e. the original version inside the package). To do this, you just need to use the `data()` function with the data set name as its argument. Let's try to modify one value of `sahp` and recover the data set afterward.
```{r, results=TRUE}
sahp[1,2]              #get the original value
sahp[1,2] <- 5         #modify the value
sahp[1,2]              #verify the modified value
data(sahp)             #recover the data
sahp[1,2]              #verify the value is recovered
```




