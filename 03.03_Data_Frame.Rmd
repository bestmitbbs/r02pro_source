## Data Frame {#dataframe}

So far, we have learned vectors (Chapter \@ref(r-objects)), matrices (Section \@ref(matrix)), and arrays (Section \@ref(array)). The three different object types share an important features: they all consist of elements of the same type, namely numeric, character, or logical. In real applications, it is common to have mixed variable types. To accommodate this, let's introduce a new object type, namely the **data frame**. 

### Introduction to Data Frames

To create a data frame, you can use the `data.frame()` function with a collection of vectors of the same length. Let's see an example of some health conditions of a sheep and a pig over the years 2019, 2020 and 2021. 
```{r, results=TRUE}
animal <- rep(c("sheep", "pig"), c(3,3))
year <- rep(2019:2021, 2)
weight <- c(110, 120, 140, NA, 300, 800)
height <- c(2.2, 2.4, 2.7, 2, 2.1, 2.3)
condition <- c("excellent", "good", NA, "excellent", "good", "average")
condition <- factor(condition, ordered = TRUE, levels = c("average", "good", "excellent"))
healthy <- c(rep(TRUE, 5), FALSE)
my_data_frame <- data.frame(animal, year, weight, height, condition, healthy)
my_data_frame
```

Looking at the data frame `my_data_frame`, it has 6 columns, each of which represents one variable. The variables are of different types. The `animal` is factor, `year` is integer, both `weight` and `height` are doubles, `condition` is ordered factor, and `healthy` is logical. '


::: {.infobox .caution data-latex="{caution}"}
This kind of data representation is impossible using matrices since the coercion rule will apply, converting everything into characters. Let's combine everything into a matrix and check its value. 
```{r, results=TRUE}
my_mat <- cbind(animal, year, weight, height, condition, healthy)
my_mat
```
::: 

In the process of creating data frames, you can also name each column.
```{r, eval=FALSE}
my_data_frame2 <- data.frame(ani = animal, y = year, w = weight, h = height, con = condition, hea = healthy)
```

After creating the data frame, it is useful to examine its class using the `class()` function and structure using the `str()` function. 

```{r, results=TRUE}
class(my_data_frame)
str(my_data_frame)
```

The `str()` tells us the data frame has 6 observations and 6 variables, along with the type and the first few values of each variable. From the output, you may be puzzled by the `$` symbol before each variable name. In fact, you can easily extract a certain column corresponding to a variable with its name. 

```{r, results=TRUE}
my_data_frame$animal
my_data_frame$weight
```


In Section \@ref(vector-functions), we introduced the very useful function `summary()` which gives us important summary statistics for a vector. Using `summary()` on a data frame, you get the summary statistics for each variable. 

```{r, results=TRUE}
summary(my_data_frame)
```

From the results, you can see that depending on the variable type, you get different forms of summary. 

In the object `my_data_frame`, there are two missing values represented by `NA`. To remove the observations (rows) with `NA` values, you can use the `na.omit()` on the data frame.
```{r, results=TRUE}
my_df_nona <- na.omit(my_data_frame)
my_df_nona
```

You can see that the 3rd and 4th row are removed since they both have a missing observation. 

An alternative approach to remove all rows with missing observations is to first use the `complete.cases()` function to get a logical vector of whether a row has missing elements, and then use data frame subsetting. 
```{r}
complete_ind <- complete.cases(my_data_frame)
my_data_frame[complete_ind, ]
```


### Adding Observations or Variables in Data Frames

Sometimes, you may want to add additional observations or variables to an existing data frame. 

To add additional observations, you need to put the additional observations or variables into a new data frame, and use the `rbind()` function. 

```{r, results = TRUE}
new_obs <- data.frame(animal = "pig", year = 2018, weight = 200, height = 1.9, condition = "excellent", healthy = TRUE)
rbind(my_data_frame, new_obs)
```

To add an additional variable to the existing data frame, you just need to add a new field to the data frame.


```{r}
my_data_frame$age <- my_data_frame$year - 2015
my_data_frame
```

### Subsetting Data Frames {#subset_df}

As a two-dimensional object type, subsetting data frames is very similar to subsetting matrices. 

***a. using indices to do data frame subsetting***

The first method for data frame subsetting is to specify the desired row indices and column indices, separated by `,`. For example, we can extract the (1, 3) and (2, 4) element of `x` using the following codes. 
```{r, results=TRUE}
my_data_frame[1, 3]
my_data_frame[2, 4]
```

Similar to a matrix subsetting, if you omit the indices of one dimension, R will keep everything along that dimension. You can also use negative indices to keep everything except the provides indices. Let's see some examples. 
```{r, results=TRUE}
my_data_frame[2, ]
my_data_frame[, 2]
my_data_frame[2]       #a single index corresponds to the columns
my_data_frame[c(1,3), -c(3,4)]
```



***b. using column names to do data frame subsetting***

Since  data frames usually have column names, you can do subsetting using multiple column names. 
```{r, results = TRUE}
my_data_frame[, c("animal", "weight")]
```



***c. using logical vectors to do data frame subsetting***

Using logical vectors to do data frame subsetting is very useful. Suppose we want to find the condition of the pig in year 2021. 
```{r, results=TRUE}
is_2021 <- my_data_frame$year == 2021
is_pig <- my_data_frame$animal == "pig"
my_data_frame$condition[is_2021 & is_pig]
```

Now, let's say we want to extract all the observations with an excellent condition. 
```{r, results=TRUE}
my_data_frame[my_data_frame$condition == "excellent", ]
my_data_frame[which(my_data_frame$condition == "excellent"), ]    #remove the NA row
```



