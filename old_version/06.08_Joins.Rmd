## Joins {#joins}

So far, we have been working on a single data set. In applications, however, we often have the need to combine multiple data sets into a single one before doing data analysis. Let's prepare two data sets to show the various ways we can **join two data sets**. 

```{r}
library(tidyverse)
library(r02pro)
d1 <- ahp %>% 
  select(dt_sold, bsmt_area, bsmt_ht) %>%
  head(n = 5)
d2 <- tibble(bsmt_ht = c("Excellent", "Good", "Average", "Poor"), height = c("100+ inches", "90-99 inches", "80-89 inches", "<70 inches"))
d1
d2
```

From the results, we know `d1` is a tibble of 
5 observations and 3 variables including `dt_sold`, `bsmt_area`, and `bsmt_ht`. `d2` is another tibble of 4 observations and 2 variales including `bsmt_ht` and `height`. 

It is clear that the two tibbles share a variable named `bsmt_ht`. It could be interesting to join the two tibbles into a single one by including all variables while matching the values of `bsmt_ht`. The bridging variable `bsmt_ht` is usually called the **key** to the joining operation.

Next, we will discuss several different join operations between `d1` and `d2`, with the key being `bsmt_ht`.

### Inner Join {#inner-join}

The first type of **join** operation on two tables (`d1` and `d2`) with a set of keys is called **inner join**. You can use the `inner_join()` function, which returns all rows in `d1` such that there are matching values of all keys in `d2`.

```{r, results=TRUE}
inner <- inner_join(d1, d2, by = "bsmt_ht")
inner
```

From the result, you can see that there are 4 observations. Each observation corresponds to one row in `d1` that has a matching value in `d2` for `bsmt_ht`. The 5th observation in `d1` is dropped in the result since its `bsmt_ht` value is `"Fair"`, which doesn't have a matched observation in `d2`. 

### Left Join {#left-join}

The second type of **join** operation on two tables (`d1` and `d2`) with a set of keys is called **left join**. You can use the `left_join()` function, which returns all rows in `d1`, **no matter** whether there are matching values of all keys in `d2` or not. 


```{r, results = TRUE}
left <- left_join(d1, d2, by = "bsmt_ht")
left
```

As you can see from the result, all rows in `d1` is kept, even though the last row doesn't have a matching observation in `d2` for the variable `bsmt_ht`. In this case, the corresponding value for `height` is `NA`. 


### Right Join {#right-join}

The third type of **join** operation on two tables (`d1` and `d2`) with a set of keys is called **right join**, which works in a similar fashion as left join. You can use the `right_join()` function, which returns all rows in `d2`, **no matter** whether there are matching values of all keys in `d1` or not. 


```{r, results = TRUE}
right <- right_join(d1, d2, by = "bsmt_ht")
right
```

As you can see from the result, all rows in `d2` is kept, even though the last two rows don't have a matching observation in `d1` for the variable `bsmt_ht`. In this case, the corresponding values for `dt_sold` and `bsmt_area` are `NA`.

### Full Join {#full-join}

The fourth type of **join** operation on two tables (`d1` and `d2`) with a set of keys is called **full join**. You can use the `full_join()` function, which returns all rows in both `d1` and `d2`, **no matter** whether there are matching values of all keys in either `d1` or  `d2`. 

```{r, results = TRUE}
full <- full_join(d1, d2, by = "bsmt_ht")
full
```

As you can tell from the result, it includes all observations from both `d1` and `d2`. You can view it as the union of `left_join()` and `right_join()`. 

### Filtering Joins {#filtering-join}

For the previous four types of joins, the resulting table contains columns from both input tables. Sometimes, you may want to only keep the columns from one of the input tables. This is called **filtering joins**, meaning that it is actually doing the filtering operations like the `filter()` function we learned in Section \@ref(filter-observations). 

***a. Semi Join***

The first type of  filtering joins is called **semi join**, which returns all rows from `d1` where there are matching values in `d2` on the **keys**.

```{r, results = TRUE}
semi <- semi_join(d1, d2, by = "bsmt_ht")
semi
```

As expected, the output is the first four rows of `d1` where there are matching values of `bsmt_area` in `d2`. Note that only the columns of `d1` are kept in the output, making it a filtering operation. 

***b. Anti Join***

Another type of  filtering joins is called **anti join**, which returns all rows from `d1` where there **don't exist** matching values in `d2` on the **keys**. 

```{r, results = TRUE}
anti <- anti_join(d1, d2, by = "bsmt_ht")
anti
```

The output only contains rows of `d1` where there are **no** matching values of `bsmt_area` in `d2`, which contains only the last row of `d1`. Again, only the columns of `d1` are kept in the output, making it another filtering operation.

### A Summary of All Joins

Finally, we summarize all the six joins in the following table, in terms of which rows and columns are selected in the final output.

```{r echo = FALSE, results = TRUE}
Type  <- c("`inner_join(d1, d2, by)`","`left_join(d1, d2, by)`","`right_join(d1, d2, by)`","`full_join(d1, d2, by)`","`semi_join(d1, d2, by)`","`anti_join(d1, d2, by)`")
Rows <- c("All in `d1` and `d2`", "All in `d1`", "All in `d2`", "All  in `d1` or `d2`", "Only in `d1` with matching keys in `d2`", "Only  in `d1` with no matching keys in `d2`")
Columns <- rep(c("All columns in `d1` and `d2`", "Only columns in `d1`"), c(4,2))
d <- tibble(`Code` = Type, Rows, Columns )
knitr::kable(d)%>%kableExtra::collapse_rows(columns = 3)
```

